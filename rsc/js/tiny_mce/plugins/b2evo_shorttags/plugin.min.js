tinymce.PluginManager.add( 'b2evo_shorttags', function( editor ) {

	var win;
	var tags = {};
	var selected;

	editor.addButton( 'b2evo_image', {
		text: '[image:]',
		icon: false,
		tooltip: 'Insert Image',
		onclick: function() {
			if( editor.getParam( 'postID' ) ) 	{
				var attachments = editor.getParam( 'attachments' );
				var inlineImages = [];
				for( var i = 0; i < attachments.length; i++ )
				{
					if( attachments[i].type == 'image' && attachments[i].position == 'inline' ) {
						inlineImages.push( attachments[i] );
					}
				}
				if( ! jQuery.isEmptyObject( inlineImages ) ) {
					showDialog( inlineImages );
				}
				else
				{
					alert( 'You must have at least one attached image in the Inline position.' );
				}
			} else {
				alert( 'You must save the post (at least as a draft) before you can attach images.' );
			}
		}
	} );

	function buildListItems( inputList, itemCallback, filetype) {
		function appendItems( values, output ) {
			output = output || [];

			tinymce.each( values, function( item ) {
				if( filetype && filetype != item.type )
				{
					// Do nothing
				}
				else
				{
					menuItem = { text: item.title || item.name, value: item.link_ID };
					output.push( menuItem );
				}
			} );

			return output;
		}

		return appendItems( inputList, [] );
	}

	function showDialog( attachmentList )
	{
		if( attachmentList ) {
			imageListCtrl = {
				type: 'listbox',
				name: 'link',
				label: 'Attached images',
				values: buildListItems(
						attachmentList,
						function( item ) {
							item.value = editor.convertURL( item.value || item.url, 'src' );
						},
						'image'
					)
			};
		}

		win = editor.windowManager.open({
			title: 'Insert/Edit Image',
			body: [
				imageListCtrl,
				{
					type: 'container',
					label: 'Caption:',
					layout: 'flex',
					direction: 'row',
					align: 'center',
					spacing: 5,
					items: [
						{
							type: 'textbox',
							name: 'caption'
						},
						{
							type: 'checkbox',
							name: 'nocaption',
							text: 'Do not show caption',
							onclick: function() {
								var captionCtrl = win.find( '#caption' )[0];
								captionCtrl.disabled( this.checked() );
							}
						}
					]
				},
				{
					type: 'listbox',
					name: 'alignment',
					label: 'Alignment:',
					values: [
						{ text: 'none', value: '' },
						{ text: 'left', value: '.floatleft' },
						{ text: 'right', value: 'floatright' }
					]
				},
				{
					type: 'textbox',
					name: 'imageClass',
					label: 'Additional class:'
				}
			],
			buttons: [
				{
					text: 'Cancel',
					onclick: 'close'
				},
				{
					text: 'Insert',
					onclick: function() {
						var linkCtrl = win.find('#link')[0];
						var captionCtrl = win.find('#caption')[0];
						var noCaptionCtrl = win.find('#nocaption')[0];
						var alignCtrl = win.find('#alignment')[0];
						var classCtrl = win.find('#imageClass')[0];
						var tag = '[image:' + linkCtrl.value();
						if( noCaptionCtrl.checked() )
						{
							tag += ':-';
						}
						else if( captionCtrl.value() ||  alignCtrl.value() )
						{
							tag += ':';
							if( captionCtrl.value() )
							{
								tag += captionCtrl.value();
							}
							if( alignCtrl.value() || classCtrl.value() )
							{
								tag += ':' + alignCtrl.value() + classCtrl.value();
							}
						}

						tag += ']';
						editor.execCommand( 'mceInsertContent', false, tag );
						renderInlineTags();
						editor.windowManager.close();
					}
				}
			]
		})
	}

	function getRenderedTags( inlineTags, callback  ) {
		var tags = [];
		for( var i = 0; i < inlineTags.length; i++ ) {
			tags.push( 'tags[]=' + encodeURI( inlineTags[i] ) );
		}
		tags = tags.join( '&' );

		tinymce.util.XHR.send({
			url: editor.getParam( 'async_url' ) + '?action=render_inlines&p=' + editor.getParam( 'postID' ),
			content_type : 'application/x-www-form-urlencoded',
			data: tags,
			success: function( data ) {
				var renderedTags = tinymce.util.JSON.parse( data );
				callback( renderedTags );
			}
		});
	}

	function embedTag( html, tag )
	{
		var re = /(<[^\s>]*)/i;
		var subst = '$1 data-b2evo-tag="' + tag + '"';
		if( html )	{
			html = html.replace( re, subst );
		}

		return html;
	}

	function renderInlineTags()
	{
		var content = editor.getContent();
		var re = /\[(image|video|audio):(\d+):?([^\[\]]*)\]/ig;
		var m;
		var matches = [];
		var inlineTags = [];

		while ((m = re.exec(content)) !== null) {
			if (m.index === re.lastIndex) {
					re.lastIndex++;
			}
			matches.push({
				shortTag: m[0],
				inlineType: m[1],
				linkId: parseInt( m[2] ),
				other: m[3]
			});
			inlineTags.push( m[0] );
		}

		getRenderedTags( inlineTags, function( renderedTags ) {
			for( tag in renderedTags ) {
				var tmpWrapper = editor.dom.create( 'div' );
				var tmp = editor.dom.createFragment( renderedTags[tag] );
				var att = document.createAttribute( 'data-b2evo-tag' );
				att.value = window.encodeURIComponent( tag );
				tmp.childNodes[0].setAttributeNode( att );
				tmp.childNodes[0].className += ' b2evo_shorttag';
				tmpWrapper.appendChild( tmp );
				tags[tag] = tmpWrapper.innerHTML;
			}

			var n = matches.length;
			var parser = new DOMParser();
			var el;
			for( var i = 0; i < n; i++ )
			{
				var data = window.encodeURIComponent( matches[i].shortTag );
				if( typeof tags[matches[i].shortTag] !== undefined ) {
					switch( matches[i].inlineType )	{
						case 'image':
							// embed shortag metadata
							//var renderedTag = embedTag( tags[matches[i].shortTag], data );
							var renderedTag = tags[matches[i].shortTag];
							var tmp = editor.dom.create( 'div' );
							tmp.innerHTML = renderedTag;

							content = content.replace( matches[i].shortTag, tmp.innerHTML );
							break;

						default:
							content = content.replace( matches[i].shortTag, '<span style="color: green;" data-b2evo-tag="' + data + '">' + matches[i].shortTag + '</span>' );
					}
				}	else {
					content = content.replace( matches[i].shortTag, '<span style="color: red;" data-b2evo-error="' + data + '">' + matches[i].shortTag + '</span>' );
				}
			}

			editor.setContent( content );
		} );
	}

	function restoreShortTags( content ) {
		// Cleanup errors
		content = content.replace( /(<span [^>]+data-b2evo-error[^>]+>(.*?)<\/span>)/ig,
			function( match, c, i )	{
				return i;
			});

		// Cleanup [image:]
		var df = editor.dom.createFragment( content );
		var tag;
		while( tag = df.querySelector( '.b2evo_shorttag' ) ) {
			var data = window.decodeURIComponent( tag.getAttributeNode( 'data-b2evo-tag' ).value );
			tag.parentNode.replaceChild( document.createTextNode( data ), tag );
		}

		var tmpWrapper = editor.dom.create( 'div' );
		tmpWrapper.appendChild( df );

		return tmpWrapper.innerHTML;
	}

	editor.on( 'PostProcess', function( event )	{
		if( event.get )
		{
			event.content = restoreShortTags( event.content );
		}
	});

	editor.on( 'attachmentsLoaded', function( event ) {
		renderInlineTags();
	} );

	function getShortTag( node, nodeId ) {
		if( !nodeId ) nodeId = 'data-b2evo-tag';

		while( node, node.parentNode ) {
			if( node.getAttribute( nodeId ) ) {
				return node;
			}

			node = node.parentNode;
		}

		return false;
	}

	editor.on( 'init', function() {
		var scrolled = false,
			selection = editor.selection,
			MutationObserver = window.MutationObserver || window.WebKitMutationObserver;

		// When a view is selected, ensure content that is being pasted
		// or inserted is added to a text node (instead of the view).
		editor.on( 'BeforeSetContent', function() {
			var walker, target,
				shortTag = getShortTag( selection.getNode() );

			// If the selection is not within a view, bail.
			if ( ! shortTag ) {
				return;
			}

			if ( ! shortTag.nextSibling || getShortTag( shortTag.nextSibling ) ) {
				// If there are no additional nodes or the next node is a
				// view, create a text node after the current view.
				target = editor.getDoc().createTextNode('');
				editor.dom.insertAfter( target, shortTag );
			} else {
				// Otherwise, find the next text node.
				walker = new TreeWalker( shortTag.nextSibling, shortTag.nextSibling );
				target = walker.next();
			}

			// Select the `target` text node.
			selection.select( target );
			selection.collapse( true );
		});

		editor.dom.bind( editor.getDoc(), 'touchmove', function() {
			scrolled = true;
		});

		editor.on( 'mousedown mouseup click touchend', function( event ) {
			var shortTag = getShortTag( event.target );

			// Contain clicks inside the view wrapper
			if ( shortTag ) {
				//event.stopImmediatePropagation();
				//event.preventDefault();

				if ( event.type === 'touchend' && scrolled ) {
					scrolled = false;
				} else {
					selected = shortTag;
					//editor.selection.select( shortTag );
				}

				//editor.nodeChanged();


				// Returning false stops the ugly bars from appearing in IE11 and stops the view being selected as a range in FF.
				// Unfortunately, it also inhibits the dragging of views to a new location.

				//return false;
				return true;
			} else {
				if ( event.type === 'touchend' || event.type === 'mousedown' ) {
				}
			}

			if ( event.type === 'touchend' && scrolled ) {
				scrolled = false;
			}
		}, true );

		editor.getDoc().addEventListener( 'drop', function( event ) {
			console.log( event );
			event.preventDefault();
		})
	});


} );