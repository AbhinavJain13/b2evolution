tinymce.PluginManager.add( 'b2evo_shorttags', function( editor ) {

	var win;
	var renderedTags = [];
	var selected, selectedTag;

	editor.addButton( 'b2evo_image', {
		text: '[image:]',
		icon: false,
		tooltip: 'Insert Image',
		onclick: function() {
			if( editor.getParam( 'postID' ) ) 	{
				var attachments = editor.getParam( 'attachments' );
				var inlineImages = [];
				for( var i = 0; i < attachments.length; i++ )
				{
					if( attachments[i].type == 'image' && attachments[i].position == 'inline' ) {
						inlineImages.push( attachments[i] );
					}
				}
				if( ! jQuery.isEmptyObject( inlineImages ) ) {
					showDialog( inlineImages );
				}
				else
				{
					alert( 'You must have at least one attached image in the Inline position.' );
				}
			} else {
				alert( 'You must save the post (at least as a draft) before you can attach images.' );
			}
		}
	} );

	function buildListItems( inputList, itemCallback, filetype) {
		function appendItems( values, output ) {
			output = output || [];

			tinymce.each( values, function( item ) {
				if( filetype && filetype != item.type )
				{
					// Do nothing
				}
				else
				{
					menuItem = { text: item.title || item.name, value: item.link_ID };
					output.push( menuItem );
				}
			} );

			return output;
		}

		return appendItems( inputList, [] );
	}

	function showDialog( attachmentList )
	{
		if( attachmentList ) {
			imageListCtrl = {
				type: 'listbox',
				name: 'link',
				label: 'Attached images',
				values: buildListItems(
						attachmentList,
						function( item ) {
							item.value = editor.convertURL( item.value || item.url, 'src' );
						},
						'image'
					)
			};
		}

		win = editor.windowManager.open({
			title: 'Insert/Edit Image',
			body: [
				imageListCtrl,
				{
					type: 'container',
					label: 'Caption:',
					layout: 'flex',
					direction: 'row',
					align: 'center',
					spacing: 5,
					items: [
						{
							type: 'textbox',
							name: 'caption'
						},
						{
							type: 'checkbox',
							name: 'nocaption',
							text: 'Do not show caption',
							onclick: function() {
								var captionCtrl = win.find( '#caption' )[0];
								captionCtrl.disabled( this.checked() );
							}
						}
					]
				},
				{
					type: 'listbox',
					name: 'alignment',
					label: 'Alignment:',
					values: [
						{ text: 'none', value: '' },
						{ text: 'left', value: '.floatleft' },
						{ text: 'right', value: 'floatright' }
					]
				},
				{
					type: 'textbox',
					name: 'imageClass',
					label: 'Additional class:'
				}
			],
			buttons: [
				{
					text: 'Cancel',
					onclick: 'close'
				},
				{
					text: 'Insert',
					onclick: function() {
						var linkCtrl = win.find('#link')[0];
						var captionCtrl = win.find('#caption')[0];
						var noCaptionCtrl = win.find('#nocaption')[0];
						var alignCtrl = win.find('#alignment')[0];
						var classCtrl = win.find('#imageClass')[0];
						var tag = '[image:' + linkCtrl.value();
						if( noCaptionCtrl.checked() )
						{
							tag += ':-';
						}
						else if( captionCtrl.value() ||  alignCtrl.value() )
						{
							tag += ':';
							if( captionCtrl.value() )
							{
								tag += captionCtrl.value();
							}
							if( alignCtrl.value() || classCtrl.value() )
							{
								tag += ':' + alignCtrl.value() + classCtrl.value();
							}
						}

						tag += ']';
						editor.execCommand( 'mceInsertContent', false, tag );
						renderInlineTags();
						editor.windowManager.close();
					}
				}
			]
		})
	}

	function getRenderedTags( inlineTags, callback  ) {
		var tagsParam = [];
		for( var i = 0; i < inlineTags.length; i++ ) {
			var renderedTag = getRenderedTag( inlineTags[i] );
			if( renderedTag === false ) {
				renderedTags.push({
					shortTag: inlineTags[i],
					html: null,
					node: null,
					rendered: false
				});
			} else {
				continue;
			}
			tagsParam.push( 'tags[]=' + encodeURI( inlineTags[i] ) );
		}

		if( tagsParam.length )
		{
			tagsParam = tagsParam.join( '&' );
			console.log( 'Fetching rendered tags...' );
			tinymce.util.XHR.send({
				url: editor.getParam( 'async_url' ) + '?action=render_inlines&p=' + editor.getParam( 'postID' ),
				content_type : 'application/x-www-form-urlencoded',
				data: tagsParam,
				success: function( data ) {
					var renderedTags = tinymce.util.JSON.parse( data );
					callback( renderedTags );
				}
			});
		}
		else
		{
			callback();
		}
	}

	function getRenderedTag( tag ) {
		var n = renderedTags.length;
		for( var i = 0; i < n; i++ )
		{
			if( renderedTags[i].shortTag == tag ) {
				return renderedTags[i];
			}
		}

		return false;
	}

	function renderInlineTags( content )
	{
		var re = /(<span.*?data-b2evo-tag.*?>)?(\[(image|video|audio):(\d+):?([^\[\]]*)\])(<\/span>)?/ig;
		var m;
		var matches = [];
		var inlineTags = [];

		while ( ( m = re.exec( content ) ) !== null ) {
			if ( m.index === re.lastIndex ) {
					re.lastIndex++;
			}
			matches.push({
				shortTag: m[2],
				inlineType: m[3],
				linkId: parseInt( m[4] ),
				other: m[5],
				openTag: m[1],
				closeTag: m[6]
			});
			inlineTags.push( m[2] );
		}

		getRenderedTags( inlineTags, function( returnedTags ) {
			if( returnedTags )
			{
				for( tag in returnedTags ) {
					var wrapper = editor.dom.create( 'div' );
					var df = editor.dom.createFragment( returnedTags[tag] );

					editor.dom.setAttrib( df.childNodes[0], 'data-b2evo-tag', window.encodeURIComponent( tag ) );
					//editor.dom.setAttrib( df.childNodes[0], 'draggable', true );

					wrapper.appendChild( df );

					var renderedTag = getRenderedTag( tag );
					if( renderedTag === false )
					{
						renderedTags.push({
							shortTag: tag,
							html: wrapper.innerHTML,
							node: wrapper.childNodes[0],
							rendered: true
						});
					}
					else if( renderedTag.rendered === false )
					{
						renderedTag.html = wrapper.innerHTML;
						renderedTag.node = wrapper.childNodes[0];
						renderedTag.rendered = true;
					}
				}

				update();
			}
		});

		var n = matches.length;
		for( var i = 0; i < n; i++ )
		{
			if( matches[i] && !matches[i].openTag && !matches[i].closeTag )
			{
				var tag = matches[i].shortTag;

				var renderedTag = getRenderedTag( tag );
				if( renderedTag !== false && renderedTag.rendered !== false )
				{
					switch( matches[i].inlineType ) {
						case 'image':
							content = content.replace( tag, renderedTag.html );
							break;

						default:
							content = content.replace( tag, '<span style="color: green;" data-b2evo-tag>' + tag + '</span>' );
					}
				}
			}
		}

		return content;
	}

	function restoreShortTags( content ) {
		// Cleanup errors
		content = content.replace( /(<span [^>]+data-b2evo-error[^>]+>(.*?)<\/span>)/ig,
			function( match, c, i )	{
				return i;
			});

		// Cleanup other shorttags
		var re = /(<span.*?data-b2evo-tag.*?>)?(\[(image|video|audio):(\d+):?([^\[\]]*)\])(<\/span>)?/ig;
		while ( ( m = re.exec( content ) ) !== null ) {
			if ( m.index === re.lastIndex ) {
					re.lastIndex++;
			}
			if( m[1] && m[6] ) {
				content = content.replace( m[0], m[2] );
			}
		}

		// Cleanup [image:]
		var df = editor.dom.createFragment( content );
		var tag;
		while( tag = df.querySelector( '[data-b2evo-tag]' ) ) {
			var data = window.decodeURIComponent( tag.getAttributeNode( 'data-b2evo-tag' ).value );
			tag.parentNode.replaceChild( document.createTextNode( data ), tag );
		}

		var tmpWrapper = editor.dom.create( 'div' );
		tmpWrapper.appendChild( df );

		return tmpWrapper.innerHTML;
	}

	function update() {
		var content = editor.getContent();
		editor.setContent( renderInlineTags( content ) );
	}

	function getRenderedNode( node, nodeId ) {
		if( !nodeId ) nodeId = 'data-b2evo-tag';

		while( node, node.parentNode ) {

			if( node.nodeName != '#text' && node.getAttribute( nodeId ) ) {
				return node;
			}

			node = node.parentNode;
		}

		return false;
	}

	editor.on( 'BeforeSetContent', function( event )  {
		event.content = renderInlineTags( event.content );
	});

	editor.on( 'PostProcess', function( event )	{
		if( event.get )
		{
			event.content = restoreShortTags( event.content );
		}
	});

	editor.on( 'attachmentsLoaded', function( event ) {
		update();
	});

	editor.on( 'dragstart', function( event ) {
		var rNode = getRenderedNode( event.target );

		if( rNode )
		{
			selected = rNode;
			var tag = window.decodeURIComponent( rNode.getAttribute( 'data-b2evo-tag' ) );
			event.dataTransfer.setData( 'application/x-moz-node', event.target );
			event.dataTransfer.setData( 'text/plain', tag );
			event.dataTransfer.effectAllowed = 'move';
		}
		else
		{
			selected = null;
		}
	});

	editor.on( 'drop', function( event ) {
		var target = event.target,
			tag = event.dataTransfer.getData( 'text/plain' );

		if( target.tagName == 'BODY' )
		{
			console.log( 'Body Target' );
			event.preventDefault();
			return false;
		}

		if( tag && selected ) {
			event.preventDefault();
			var textNode = editor.getDoc().createTextNode( tag );
			editor.dom.insertAfter( textNode, target );
			editor.dom.remove( selected );
			update();
			return false;
		}
	});

	editor.on( 'init', function() {
		var scrolled = false,
			selection = editor.selection;

		// When a renderedNode is selected, ensure content that is being pasted
		// or inserted is added to a text node (instead of the renderedNode).
		editor.on( 'BeforeSetContent', function() {
			var walker, target,
				rNode = getRenderedNode( selection.getNode() );

			// If the selection is not within a renderedNode, bail.
			if ( !rNode ) {
				return;
			}

			if ( !rNode.nextSibling || getRenderedNode( rNode.nextSibling ) ) {
				// If there are no additional nodes or the next node is a
				// renderedNode, create a text node after the current renderedNode.
				target = editor.getDoc().createTextNode('');
				editor.dom.insertAfter( target, rNode );
			} else {
				// Otherwise, find the next text node.
				walker = new tinymce.dom.TreeWalker( rNode.nextSibling, rNode.nextSibling );
				target = walker.next();
			}

			// Select the `target` text node.
			selection.select( target );
			selection.collapse( true );
		});
	});

});